import os
import time
import subprocess
import torch
import pysam
from pathlib import Path
from Bio import SeqIO
import re

def preprocess_sam_for_paftools(sam_file_path, processed_sam_file_path):
    with open(sam_file_path, "r") as infile, open(processed_sam_file_path, "w") as outfile:
        for line in infile:
            if line.startswith("@"):  # Skip header lines
                outfile.write(line)
            else:
                # Modify read name by removing the UUID part (if it exists)
                fields = line.split("\t")
                read_name = fields[0]
                # Remove UUID from read name (assuming UUID format like 'read_b5268d0d-f801-4d53-bdf9-e1e28b933ffd')
                new_read_name = re.sub(r"read_[a-f0-9\-]+", "read", read_name)
                fields[0] = new_read_name
                outfile.write("\t".join(fields) + "\n")

    print(f"Modified SAM file saved as {processed_sam_file_path}")

def basecall_with_bonito(model_path, input_dir, output_fastq, reference, batchsize=32, device="cuda"):
    """
    Perform basecalling using a Bonito-trained model.
    """
    print("Starting basecalling with Bonito...")
    bonito_command = [
        "bonito", "basecaller", model_path, input_dir,
        "--device", device,
        "--batchsize", str(batchsize),
        "--reference", reference,
    ]
    start_time = time.time()
    # Redirect output to a FASTQ file
    with open(output_fastq, "w") as fastq_file:
        subprocess.run(bonito_command, stdout=fastq_file, check=True)
    duration = time.time() - start_time
    print(f"Basecalling completed in {duration:.2f} seconds.")
    return duration

def align_basecalls_to_reference(basecalls, reference, sam_output):
    """
    Align basecalled reads to the reference using Minimap2.
    """
    print("Aligning basecalls to reference...")
    minimap_command = [
        "minimap2", "-ax", "map-ont", reference, basecalls
    ]
    with open(sam_output, "w") as sam_file:
        subprocess.run(minimap_command, stdout=sam_file, check=True)
    print("Alignment completed.")

def compare_sam_files(sam_file_basecaller, sam_file_reference):
    """
    Compares two SAM files to calculate the accuracy metrics (matches, mismatches, insertions, deletions).
    
    Args:
        sam_file_basecaller (str): Path to the SAM file generated by the basecaller.
        sam_file_reference (str): Path to the SAM file based on the reference genome.
        
    Returns:
        dict: Accuracy metrics including matches, mismatches, insertions, deletions, and overall accuracy.
    """
    # Open the SAM files
    sam_basecaller = pysam.AlignmentFile(sam_file_basecaller, "rb")
    sam_reference = pysam.AlignmentFile(sam_file_reference, "rb")
    
    total_matches = 0
    total_mismatches = 0
    total_insertions = 0
    total_deletions = 0
    total_bases = 0

    for read_basecaller in sam_basecaller.fetch():
        if read_basecaller.is_unmapped:  # Skip unmapped reads
            continue
        
        # Find the corresponding reference read (by query name)
        read_reference = sam_reference.fetch(read_basecaller.query_name)
        if read_reference:
            read_reference = next(read_reference)  # Assume there's only one matching reference read

            query_seq = read_basecaller.query_sequence
            ref_seq = read_reference.query_sequence

            # Parse the CIGAR string to determine matches, mismatches, insertions, and deletions
            ref_pos = 0  # Position in reference sequence
            query_pos = 0  # Position in query sequence

            for cigar_op, length in read_basecaller.cigartuples:
                if cigar_op == 0:  # Match or mismatch
                    query_segment = query_seq[query_pos:query_pos + length]
                    ref_segment = ref_seq[ref_pos:ref_pos + length]
                    for q, r in zip(query_segment, ref_segment):
                        if q == r:
                            total_matches += 1
                        else:
                            total_mismatches += 1
                    query_pos += length
                    ref_pos += length
                elif cigar_op == 1:  # Insertion in query
                    total_insertions += length
                    query_pos += length
                elif cigar_op == 2:  # Deletion in reference
                    total_deletions += length
                    ref_pos += length
                elif cigar_op in (3, 4, 5):  # Clipped regions or skipped reference bases
                    continue

    # Calculate total bases and accuracy
    total_bases = total_matches + total_mismatches + total_insertions + total_deletions
    accuracy = total_matches / total_bases if total_bases > 0 else 0.0
    
    return {
        "matches": total_matches,
        "mismatches": total_mismatches,
        "insertions": total_insertions,
        "deletions": total_deletions,
        "accuracy": accuracy,
    }

def measure_model_size(model_path):
    """
    Measure the model size in megabytes.
    """
    weights_file = Path(model_path) / 'weights_1.tar'
    if not Path(weights_file).exists():
        print(f"Error: Model file at {model_path} does not exist.")
        return 0
    model_size = Path(weights_file).stat().st_size / (1024 * 1024)
    print(f"Model size: {model_size:.2f} MB")
    return model_size

def evaluate_bonito_model(model_path, data_dir, reference, output_dir):
    """
    Evaluate a Bonito model on accuracy, throughput, and size.
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(exist_ok=True, parents=True)
    
    basecalls_fastq = output_dir / "basecalls.fastq"
    alignment_sam_basecaller = output_dir / "alignment_basecaller.sam"
    alignment_sam_reference = output_dir / "alignment_reference.sam"

    # Basecalling
    throughput = basecall_with_bonito(
        model_path=model_path,
        input_dir=data_dir,
        output_fastq=basecalls_fastq,
        reference=reference,
    )
    
    # Align basecalls
    align_basecalls_to_reference(
        basecalls=basecalls_fastq,
        reference=reference,
        sam_output=alignment_sam_basecaller,
    )

    # Compare the SAM files (basecaller output vs reference alignment)
    accuracy_metrics = compare_sam_files(alignment_sam_basecaller, alignment_sam_reference)

    # Measure model size
    model_size = measure_model_size(model_path=model_path)

    return {
        "accuracy_metrics": accuracy_metrics,
        "throughput_seconds": throughput,
        "model_size_mb": model_size,
    }

if __name__ == "__main__":
    # Define paths and parameters
    model_path = "./model_dir/mamba_256"  # Path to Bonito model
    data_dir = "./squigulator/test_dataset/test_pod5/"  # Directory containing .pod5 files
    reference = "./squigulator/test_dataset/fasta/all_5mers.fa"     # Path to reference fasta file
    output_dir = "./squigulator/test_dataset/results/" # Directory for results

    # Evaluate the model
    results = evaluate_bonito_model(model_path, data_dir, reference, output_dir)
    print("\nEvaluation Results:")
    print(f"Accuracy Metrics: {results['accuracy_metrics']}")
    print(f"Throughput: {results['throughput_seconds']:.2f} seconds")
    print(f"Model Size: {results['model_size_mb']:.2f} MB")
